{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"annotations":{"capability.openshift.io/name":"OptionalMonitoring", "api-approved.openshift.io":"https://github.com/openshift/api/pull/1406","api.openshift.io/merged-by-featuregates":"true","description":"OpenShift Monitoring alerting rules","include.release.openshift.io/ibm-cloud-managed":"true","include.release.openshift.io/self-managed-high-availability":"true"},"name":"alertingrules.monitoring.openshift.io"},"spec":{"group":"monitoring.openshift.io","names":{"kind":"AlertingRule","listKind":"AlertingRuleList","plural":"alertingrules","singular":"alertingrule"},"scope":"Namespaced","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"description":"AlertingRule represents a set of user-defined Prometheus rule groups containing\nalerting rules.  This resource is the supported method for cluster admins to\ncreate alerts based on metrics recorded by the platform monitoring stack in\nOpenShift, i.e. the Prometheus instance deployed to the openshift-monitoring\nnamespace.  You might use this to create custom alerting rules not shipped with\nOpenShift based on metrics from components such as the node_exporter, which\nprovides machine-level metrics such as CPU usage, or kube-state-metrics, which\nprovides metrics on Kubernetes usage.\n\nThe API is mostly compatible with the upstream PrometheusRule type from the\nprometheus-operator.  The primary difference being that recording rules are not\nallowed here -- only alerting rules.  For each AlertingRule resource created, a\ncorresponding PrometheusRule will be created in the openshift-monitoring\nnamespace.  OpenShift requires admins to use the AlertingRule resource rather\nthan the upstream type in order to allow better OpenShift specific defaulting\nand validation, while not modifying the upstream APIs directly.\n\nYou can find upstream API documentation for PrometheusRule resources here:\n\nhttps://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md\n\nCompatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).","properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"spec describes the desired state of this AlertingRule object.","properties":{"groups":{"description":"groups is a list of grouped alerting rules.  Rule groups are the unit at\nwhich Prometheus parallelizes rule processing.  All rules in a single group\nshare a configured evaluation interval.  All rules in the group will be\nprocessed together on this interval, sequentially, and all rules will be\nprocessed.\n\nIt's common to group related alerting rules into a single AlertingRule\nresources, and within that resource, closely related alerts, or simply\nalerts with the same interval, into individual groups.  You are also free\nto create AlertingRule resources with only a single rule group, but be\naware that this can have a performance impact on Prometheus if the group is\nextremely large or has very complex query expressions to evaluate.\nSpreading very complex rules across multiple groups to allow them to be\nprocessed in parallel is also a common use-case.","items":{"description":"RuleGroup is a list of sequentially evaluated alerting rules.","properties":{"interval":{"description":"interval is how often rules in the group are evaluated.  If not specified,\nit defaults to the global.evaluation_interval configured in Prometheus,\nwhich itself defaults to 30 seconds.  You can check if this value has been\nmodified from the default on your cluster by inspecting the platform\nPrometheus configuration:\nThe relevant field in that resource is: spec.evaluationInterval","maxLength":2048,"pattern":"^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$","type":"string"},"name":{"description":"name is the name of the group.","maxLength":2048,"minLength":1,"type":"string"},"rules":{"description":"rules is a list of sequentially evaluated alerting rules.  Prometheus may\nprocess rule groups in parallel, but rules within a single group are always\nprocessed sequentially, and all rules are processed.","items":{"description":"Rule describes an alerting rule.\nSee Prometheus documentation:\n- https://www.prometheus.io/docs/prometheus/latest/configuration/alerting_rules","properties":{"alert":{"description":"alert is the name of the alert. Must be a valid label value, i.e. may\ncontain any Unicode character.","maxLength":2048,"minLength":1,"type":"string"},"annotations":{"additionalProperties":{"type":"string"},"description":"annotations to add to each alert.  These are values that can be used to\nstore longer additional information that you won't query on, such as alert\ndescriptions or runbook links.","type":"object"},"expr":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"expr is the PromQL expression to evaluate. Every evaluation cycle this is\nevaluated at the current time, and all resultant time series become pending\nor firing alerts.  This is most often a string representing a PromQL\nexpression, e.g.: mapi_current_pending_csr \u003e mapi_max_pending_csr\nIn rare cases this could be a simple integer, e.g. a simple \"1\" if the\nintent is to create an alert that is always firing.  This is sometimes used\nto create an always-firing \"Watchdog\" alert in order to ensure the alerting\npipeline is functional.","x-kubernetes-int-or-string":true},"for":{"description":"for is the time period after which alerts are considered firing after first\nreturning results.  Alerts which have not yet fired for long enough are\nconsidered pending.","maxLength":2048,"pattern":"^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$","type":"string"},"labels":{"additionalProperties":{"type":"string"},"description":"labels to add or overwrite for each alert.  The results of the PromQL\nexpression for the alert will result in an existing set of labels for the\nalert, after evaluating the expression, for any label specified here with\nthe same name as a label in that set, the label here wins and overwrites\nthe previous value.  These should typically be short identifying values\nthat may be useful to query against.  A common example is the alert\nseverity, where one sets `severity: warning` under the `labels` key:","type":"object"}},"required":["alert","expr"],"type":"object"},"minItems":1,"type":"array"}},"required":["name","rules"],"type":"object"},"minItems":1,"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"}},"required":["groups"],"type":"object"},"status":{"description":"status describes the current state of this AlertOverrides object.","properties":{"observedGeneration":{"description":"observedGeneration is the last generation change you've dealt with.","format":"int64","type":"integer"},"prometheusRule":{"description":"prometheusRule is the generated PrometheusRule for this AlertingRule.  Each\nAlertingRule instance results in a generated PrometheusRule object in the\nsame namespace, which is always the openshift-monitoring namespace.","properties":{"name":{"description":"name of the referenced PrometheusRule.","maxLength":2048,"minLength":1,"type":"string"}},"required":["name"],"type":"object"}},"type":"object"}},"required":["spec"],"type":"object"}},"served":true,"storage":true,"subresources":{"status":{}}}]}}
